# フロントエンド・バックエンド責務分離問題の分析レポート

## 問題概要

**現象**: バックエンド単体テストは全て成功するが、フロントエンド+バックエンド統合時にセクター間移動が失敗する

**根本原因**: フロントエンドとバックエンドの責務が未分化で、重複するロジックが存在し、状態の同期が取れていない

## 調査結果

### 1. 重要な実装差異 - コマンドキュー処理

#### フロントエンド (src/ship-engine.ts:473-476)
```typescript
// 移動中でない場合、コマンドキューを自動処理
if (!ship.isMoving) {
  CommandQueue.processQueue(ship, gameState);
}
```

#### バックエンド (apps/backend/src/ship-engine.ts)
```typescript
// コマンドキューの自動処理ロジックが存在しない
gameState.player.ships.forEach(ship => {
  if (!ship.isMoving || !ship.destination) return;
  // ... 移動ロジックのみ
});
```

**問題**: フロントエンドは自動でキューを処理するが、バックエンドは外部トリガーに依存

### 2. 責務の重複と混在

#### フロントエンドが実行している本来バックエンドの責務
- **完全なルート計画** (galaxy-navigation使用)
- **楽観的状態更新** (SectorMap.tsx:276-300)
- **ローカルコマンド実行** (API呼び出し前)
- **座標変換とゲーム状態操作**

#### バックエンドの不完全な実装
- コマンドキューの自動進行なし
- ゲート到達後の自動次コマンド処理なし
- リアルタイム状態更新なし

### 3. 状態同期の問題

#### 楽観的更新による二重状態管理 (SectorMap.tsx)
```typescript
// フロントエンドが先に状態を更新
if (gameState) {
  const ship = gameState.player.ships.find(s => s.id === selectedShipId);
  if (ship) {
    ship.isMoving = true;
    ship.destination = clickedStation.position;
    ship.currentCommand = { type: 'move', target: clickedStation.id };
  }
}
```

**問題**: フロントエンド状態とバックエンド状態が乖離し、真実の源が複数存在

### 4. コマンド実行フローの不整合

#### フロントエンド実行フロー
1. ローカル状態更新（楽観的）
2. ルート計画実行
3. コマンドキューに追加
4. **即座にCommandQueue.processQueue()実行**
5. API呼び出し

#### バックエンド実行フロー
1. コマンド受信
2. ルート計画実行
3. コマンドキューに追加
4. **自動処理なし - 船が中間ゲートで停止**

## テスト成功 vs 統合失敗の原因

### バックエンドテストが成功する理由
- テストが直接`ShipEngine.executeCommand()`を呼び出し
- 必要に応じて手動で`CommandQueue.processQueue()`実行
- 個別コマンドロジックは正常動作

### 統合時に失敗する理由
- **バックエンドがコマンドキューを自動処理しない**
- **フロントエンドがローカル処理で補償しようとする**
- **コマンド実行が非同期になる**
- **中間ゲートで船が停止する**

## 具体的な問題事例

### セクター間移動の失敗パターン
1. フロントエンド：Europa Stationのステーションをクリック
2. フロントエンド：楽観的にDiscovery船の状態を更新
3. フロントエンド：ローカルでルート計画（New Tokyo → Europa Station）
4. フロントエンド：コマンドキューに[ゲート移動, ステーション移動]追加
5. フロントエンド：即座に最初のコマンド開始
6. バックエンド：コマンド受信、ルート計画、キューに追加
7. **バックエンド：自動処理せず、船が中間状態で停止**
8. **結果：Discovery船がNew Tokyoに残る**

## 推奨解決策

### 1. バックエンド修正（緊急）
```typescript
// apps/backend/src/ship-engine.ts に追加
static updateShipMovement(gameState: GameState, deltaTime: number): GameEvent[] {
  const events: GameEvent[] = [];

  gameState.player.ships.forEach(ship => {
    // 移動中でない場合、コマンドキューを自動処理 - 追加
    if (!ship.isMoving) {
      CommandQueue.processQueue(ship, gameState);
    }
    
    // ... 既存の移動ロジック
  });
}
```

### 2. フロントエンド責務削減
- 楽観的状態更新を削除
- ローカルコマンドキュー処理を削除
- バックエンドに状態遷移を委譲
- フロントエンドはコマンド送信と表示のみ

### 3. 単一責任原則の適用
#### バックエンドの責務
- 全ゲーム状態管理
- コマンドキュー管理
- セクター間ルート計画
- 船の状態遷移
- ゲームイベント生成

#### フロントエンドの責務
- ユーザーインターフェース
- コマンド送信
- 状態表示
- リアルタイム更新受信

### 4. 状態同期の改善
- 楽観的更新を削除
- アクティブ移動中のポーリング頻度増加
- WebSocketによるリアルタイム更新導入
- バックエンドを唯一の真実の源に

## 優先度付きアクションプラン

### 🔴 緊急（即時対応）
1. バックエンドのupdateShipMovementにコマンドキュー自動処理追加
2. 統合テストで動作確認

### 🟡 高優先度（短期）
1. フロントエンド楽観的更新削除
2. ローカルコマンド処理ロジック削除
3. 状態表示の整合性確保

### 🟢 中優先度（中期）
1. WebSocketリアルタイム更新導入
2. エラーハンドリング統一
3. ログとデバッグ機能強化

## 結論

現在の問題は**アーキテクチャレベルの責務分離不足**が原因です。フロントエンドとバックエンドが同じロジックを重複実装し、異なるタイミングで実行することで、状態の不整合が発生しています。

バックエンドのコマンドキュー自動処理追加が最小限の修正で最大の効果を得られる解決策です。